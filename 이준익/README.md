# 25.01.13 (월)

## Figma

### 1. 정의
**UI/UX 디자인을 위한 강력한 클라우드 기반 협업 디자인 도구**

---

### 2. 주요 특징

#### 1. 클라우드 기반
- 설치 없이 웹 브라우저에서 사용 가능.
- 작업이 실시간으로 저장되어 데이터 손실 위험이 적음.
- Windows, macOS 모두 호환.

#### 2. 실시간 협업
- 여러 명이 동시에 같은 파일에서 작업 가능.
- 실시간 커서 공유로 팀원 간의 작업 상태를 쉽게 확인 가능.
- 코멘트 기능으로 피드백이 용이.

#### 3. 다양한 디자인 기능
- 벡터 그래픽 지원.
- UI 구성 요소(Component) 생성 및 재사용.
- 다양한 플러그인으로 작업 효율성을 높임.

#### 4. 프로토타이핑
- 디자인을 연결해 사용자 흐름(Flow) 시뮬레이션 가능.
- 클릭과 애니메이션 효과 추가로 인터랙티브한 프로토타입 제작.

#### 5. 버전 관리
- 변경 내역을 자동 저장하고, 이전 버전으로 쉽게 돌아갈 수 있음.

---

### 3. 인터페이스 소개

#### 1. Toolbar (도구 모음)
- **Move Tool**: 개체 이동.
- **Frame Tool**: 화면(프레임) 생성.
- **Shape Tool**: 사각형, 원, 선 등 도형 그리기.
- **Text Tool**: 텍스트 추가.

#### 2. Left Panel (레이어와 페이지 관리)
- 레이어 및 페이지 구조를 확인하고 편집.
- 그룹화, 잠금, 숨김 등을 관리.

#### 3. Canvas (작업 영역)
- 디자인 작업이 이루어지는 공간.
- 무한 캔버스 형태로 원하는 만큼 확대/축소 가능.

#### 4. Right Panel (속성 패널)
- 선택한 요소의 속성(크기, 색상, 위치 등) 편집.
- 프로토타입 설정 및 인터랙션 추가.

#### 5. Top Menu (상단 메뉴)
- 파일 관리, 공유 설정, 플러그인 접근 가능.

---

### 4. 기본 단축키

#### 1. 기본 작업 단축키
- **새 파일 생성**: `Ctrl + N` (Windows) / `Cmd + N` (Mac)  
- **파일 열기**: `Ctrl + O` / `Cmd + O`  
- **저장**: Figma는 자동 저장됨 (별도 단축키 없음).  
- **복제(Duplicate)**: `Ctrl + D` / `Cmd + D`  
- **뒤로/앞으로 이동**: `Ctrl + [` / `Ctrl + ]` (Mac: `Cmd + [` / `Cmd + ]`)  

#### 2. 캔버스 및 이동
- **캔버스 이동(손 도구)**: `Space` (누른 상태로 드래그)  
- **확대/축소**: `Ctrl + +` / `Ctrl + -` (Mac: `Cmd + +` / `Cmd + -`)  
- **100% 크기로 보기**: `Shift + 1`  
- **전체 보기**: `Shift + 2`  

#### 3. 선택 및 이동
- **Move Tool (이동 도구)**: `V`  
- **Select (선택 도구)**: `Ctrl + Click` / `Cmd + Click`  
- **그룹 만들기**: `Ctrl + G` / `Cmd + G`  
- **그룹 해제**: `Shift + Ctrl + G` / `Shift + Cmd + G`  
- **정렬 도구 열기**: `Shift + A`  

#### 4. 도형 및 텍스트 작업
- **Frame Tool (프레임 도구)**: `F`  
- **Rectangle (사각형)**: `R`  
- **Ellipse (타원)**: `O`  
- **Line (선)**: `L`  
- **Pen Tool (펜 도구)**: `P`  
- **Text Tool (텍스트 도구)**: `T`  
- **이미지 삽입**: `Shift + Ctrl + K` / `Shift + Cmd + K`  

#### 5. 편집 작업
- **복사/붙여넣기**: `Ctrl + C` / `Ctrl + V` (Mac: `Cmd + C` / `Cmd + V`)  
- **요소 삭제**: `Delete`  
- **Undo (되돌리기)**: `Ctrl + Z` / `Cmd + Z`  
- **Redo (다시 실행)**: `Shift + Ctrl + Z` / `Shift + Cmd + Z`  
- **속성 복사**: `Alt + Ctrl + C` / `Option + Cmd + C`  
- **속성 붙여넣기**: `Alt + Ctrl + V` / `Option + Cmd + V`  

#### 6. 프로토타입 작업
- **프로토타입 모드 전환**: `Shift + E`  
- **연결선 추가**: 드래그하여 연결  
- **프레젠테이션 보기**: `Ctrl + Enter` / `Cmd + Enter`  

#### 7. 기타 유용한 단축키
- **레이어 잠금/잠금 해제**: `Ctrl + Shift + L` / `Cmd + Shift + L`  
- **레이어 숨기기/보이기**: `Ctrl + Shift + H` / `Cmd + Shift + H`  
- **Zoom to Selection (선택 영역 확대)**: `Shift + 2`  
- **레이어 이름 바꾸기**: `Ctrl + R` / `Cmd + R`  


---
<br>

# 25.01.14 (화)

## UI / UX 설계

### 1. UI와 UX의 정의
- **UI (User Interface)**: 사용자가 웹사이트나 애플리케이션과 상호작용하는 화면 및 요소.  
  - 버튼, 메뉴, 아이콘, 입력 창 등 포함.
- **UX (User Experience)**: 사용자가 제품 또는 서비스를 이용하면서 느끼는 전반적인 경험.  
  - 사용성, 접근성, 직관성 등이 포함.

---

### 2. UI/UX 설계 원칙

#### UI 설계 원칙
1. **일관성**: 색상, 글꼴, 버튼 스타일 등이 통일되어 있어야 함.
2. **직관성**: 사용자가 별도의 설명 없이도 쉽게 이해할 수 있어야 함.
3. **피드백 제공**: 사용자의 행동에 대한 즉각적인 반응 제공 (예: 버튼 클릭 시 애니메이션).
4. **가시성**: 주요 정보와 요소는 눈에 잘 띄게 배치.

#### UX 설계 원칙
1. **사용자 중심 설계**: 사용자 행동과 요구를 분석하고 이에 맞춘 설계.
2. **접근성**: 다양한 사용자(장애 포함)가 쉽게 접근 가능해야 함.
3. **간결성**: 불필요한 요소나 정보를 줄여 간단한 사용 흐름 제공.
4. **효율성**: 사용자가 작업을 더 빨리 완료할 수 있는 설계.

---

### 3. UI/UX 설계 프로세스

1. **요구사항 분석**
   - 사용자 페르소나 정의.
   - 사용자 행동 패턴 조사.
   - 주요 요구사항과 문제점 도출.

2. **와이어프레임 및 프로토타입 작성**
   - 기본 레이아웃(와이어프레임) 작성.
   - 인터랙션과 동작이 포함된 프로토타입 제작.
   - **도구**: Figma, Adobe XD, Sketch.

3. **사용자 테스트**
   - 프로토타입을 사용해 사용자 피드백 수집.
   - 문제점을 분석하고 개선.

4. **디자인 최적화**
   - UI 요소(색상, 아이콘, 글꼴) 정제.
   - 접근성 개선 (**WCAG 기준 준수**).

5. **개발 및 배포**
   - 설계를 프론트엔드 코드로 변환.
   - 지속적인 사용자 피드백 반영.

---

### 4. 디자인 도구
1. **Figma**: 협업 중심의 UI/UX 디자인 도구.
2. **Adobe XD**: 프로토타입 제작 및 인터랙션 설계에 유리.
3. **Sketch**: Mac 사용자를 위한 UI 디자인 도구.
4. **Zeplin**: 디자인과 개발 간 협업 도구.

---

### 5. 컬러와 타이포그래피

#### 컬러
- 브랜드 컬러와 일치하도록 설계.
- 대비와 가독성을 고려 (텍스트와 배경색).
- 감정과 연결된 색상 심리 활용.

#### 타이포그래피
- 기본 글꼴 크기는 **16px 이상 권장**.
- 적절한 줄 간격과 문단 간격 유지.
- **폰트 개수 제한**: 최대 2~3개.

---

### 6. 반응형 웹 디자인
- 다양한 디바이스(모바일, 태블릿, 데스크톱)에서 동일한 사용자 경험 제공.
- **미디어 쿼리**와 **유연한 레이아웃** 활용.
- 이미지와 텍스트 크기를 자동 조정.

---

### 7. 사용성 평가 및 피드백
1. **A/B 테스트**: 두 가지 UI/UX 옵션을 비교.
2. **Google Analytics**: 사용자의 행동 데이터 분석.
3. **Hotjar**: 히트맵으로 사용자가 어디를 클릭하는지 분석.
4. **사용자 인터뷰**: 질적 피드백 수집.

---

### 8. 최신 UI/UX 트렌드
1. **다크 모드**: 사용자의 눈 피로 감소.
2. **미니멀리즘**: 간단하고 깔끔한 디자인.
3. **마이크로 인터랙션**: 작은 애니메이션으로 피드백 제공.
4. **음성 인터페이스(VUI)**: 음성 명령으로 조작 가능.

---
<br>

# 25.01.15 (수)

## Web ide 동시편집 구현 테스트 (Monaco 라이브러리)

```jsx
import { useState, useRef } from 'react'
import Editor from "@monaco-editor/react"
import * as Y from "yjs"
import { WebrtcProvider } from "y-webrtc"
import { MonacoBinding } from "y-monaco"

// 모나코 에디터 설정
// YJS 텍스트를 모나코 에디터에 연결

function App() {
  const editorRef = useRef(null);

  // 에디터 값 -> YJS 텍스트 값 (여러 명이 공유하는 텍스트 값)
  // 한 사람이 텍스트를 삭제하면 -> 전체 공유 텍스트 값에서도 삭제됨
  // 이 모든 과정은 YJS에서 처리함

  // YJS 초기화, 모나코 인스턴스의 변화를 감지하도록 설정
  function handleEditorDidMount(editor, monaco) {
    editorRef.current = editor
    // YJS 초기화
    const doc = new Y.Doc() // 공유 객체 모음 -> 텍스트

    // WebRTC를 통해 다른 피어들과 연결(또는 연결 시작)
    const provider = new WebrtcProvider("test-room", doc) // room1, room2
    const type = doc.getText("monaco") // doc { "monaco": "IDE에서 보여주고 있는 내용" }

    // YJS를 모나코 에디터와 연결
    const binding = new MonacoBinding(
      type, 
      editorRef.current.getModel(),
      new Set([editorRef.current]),
      provider.awareness
    );
    console.log(provider.awareness);
  }

  return (
    <Editor
      height="100vh"
      width="100vw"
      theme="vs-dark"
      onMount={handleEditorDidMount}
    />
  )
}

export default App

```
## 코드 분석

**React**와 **Monaco 에디터**, 그리고 **YJS**(실시간 협업을 지원하는 라이브러리)를 연동해 **실시간 협업 에디터**를 구현하는 예시

---

### 1. 라이브러리 임포트

```jsx
import { useState, useRef } from 'react'
import Editor from "@monaco-editor/react"
import * as Y from "yjs"
import { WebrtcProvider } from "y-webrtc"
import { MonacoBinding } from "y-monaco"
```
- **@monaco-editor/react** <br>
   : VScode 편집기 엔진을 React 환경에서 사용할 수 있도록 만든 라이브러리
- **YJS** <br>
   : CRDT(Conflict-free Replicated Data Type) 기반으로 실시간 협업을 지원하는 라이브러리
- **y-webrtc** <br>
   : WebRTC를 통해 네트워크 상의 다른 클라이언트들과 YJS 문서를 동기화할 수 있게 해주는 라이브러리
- **y-monaco** <br>
   : YJS의 텍스트 객체와 Monaco 에디터를 바인딩해주는 어댑터로 에디터 내용을 실시간으로 공유할 수 있도록 해주는 라이브러리

---
### 2. APP 컴포넌트 선언

```jsx
function App() {
  const editorRef = useRef(null);
  ...
  return (
    <Editor
      height="100vh"
      width="100vw"
      theme="vs-dark"
      onMount={handleEditorDidMount}
    />
  )
}
```
- **editorRef** <br>
   : 모나코 에디터 인스턴스를 참조하기 위한 변수
- **Editor** <br>
   : @monaco-editor/react에서 제공하는 컴포넌트

---
### 3. handleEditorDidMount 함수

```jsx
function handleEditorDidMount(editor, monaco) {
  editorRef.current = editor

  const doc = new Y.Doc()
  const provider = new WebrtcProvider("test-room", doc)
  const type = doc.getText("monaco")
  const binding = new MonacoBinding(
    type, 
    editorRef.current.getModel(),
    new Set([editorRef.current]),
    provider.awareness
  );
  console.log(provider.awareness);
}
```
- **const doc = new Y.Doc()** <br>
   : YJS에서 협업데이터(텍스트, 맵, 배열 등)를 담는 공유 문서 생성해 다수의 사용자가 동시에 작성하는 데이터를 동기화할 수 있음
- **const provider = new WebrtcProvider("test-room", doc)** <br>
   : "test-room"이라는 방을 통해 webRTC 연결 <br>
   doc을 전달해 다른 클라이언트와 동기화하도록 만듦 <br>
   실제 배포 시에는 방 이름을 동적으로 할당하거나, 서버를 통해 관리할 수도 있음
- **const type = doc.getText("monaco")** <br>
   : doc 에서 "monaco라는 키로 텍스트를 가져옮 <br>
   이 텍스트 객체를 모나코 에디터의 내용과 동기화하게 됨
- **MonacoBinding** <br>
   : YJS의 텍스트와 모나코 에디터 모델을 연결해주는 어댑터
- **new Set([editorRef.current])** <br>
   : 에디터의 selection / 커서 등의 정보를 공유할 수 있도록 Monaco 에디터 인스턴스(집합 형태) 전달
- **provider.awareness** <br>
   : WebrtcProvider가 제공하는 awareness 객체. 사용자 커서 위치나 다른 메타정보(이 사용자는 현재 어떤 색상 테마를 쓰는지, 닉네임은 무엇인지 등)를 공유

---
<br>

# 25.01.16 (목)

## TypeScript 학습 내용 정리

### 1. 기본 타입 (Basic Types)
TypeScript에서 변수에 할당할 수 있는 기본적인 타입들은 다음과 같습니다:

- **string**: 문자열 타입  
  ```typescript
  let name: string = "John";
  ```
- **number**: 숫자 타입 (정수, 부동소수 포함)  
  ```typescript
  let age: number = 30;
  ```
- **boolean**: 논리 타입 (true/false)  
  ```typescript
  let isActive: boolean = true;
  ```
- **null**: null 값  
  ```typescript
  let nothing: null = null;
  ```
- **undefined**: 값이 정의되지 않음  
  ```typescript
  let notAssigned: undefined = undefined;
  ```
- **bigint**: 큰 정수 값을 표현  
  ```typescript
  let bigNumber: bigint = 9007199254740991n;
  ```
- **symbol**: 고유한 식별자 생성  
  ```typescript
  let sym: symbol = Symbol("unique");
  ```

---

### 2. 원시 타입과 리터럴 타입 (Primitive and Literal Types)
- **원시 타입 (Primitive Types)**:  
  기본 타입인 `string`, `number`, `boolean` 등의 데이터 타입.

- **리터럴 타입 (Literal Types)**:  
  값 자체가 타입으로 사용되는 것. 특정 값만 허용하도록 타입을 제한할 수 있음.
  ```typescript
  let direction: "left" | "right" | "up" | "down";
  direction = "left"; // 가능
  direction = "forward"; // 오류
  ```

---

### 3. 배열과 튜플 (Arrays and Tuples)
- **배열 (Array)**:  
  같은 타입의 데이터를 여러 개 저장하는 자료 구조.
  ```typescript
  let numbers: number[] = [1, 2, 3];
  let strings: Array<string> = ["a", "b", "c"];
  ```

- **튜플 (Tuple)**:  
  고정된 크기와 타입 순서를 가지는 배열.
  ```typescript
  let tuple: [string, number, boolean];
  tuple = ["hello", 42, true]; // 가능
  ```

---

### 4. 객체 (Objects)
- 객체는 여러 속성과 값을 가지며, 속성의 타입을 지정할 수 있음.
  ```typescript
  let person: { name: string; age: number; isActive: boolean } = {
    name: "John",
    age: 30,
    isActive: true,
  };
  ```

- **선택적 속성**:  
  속성 이름 뒤에 `?`를 추가하여 선택적으로 속성을 가질 수 있음.
  ```typescript
  let user: { id: number; username?: string } = { id: 1 };
  ```

---

### 5. 타입 별칭과 인덱스 시그니처 (Type Aliases and Index Signatures)
- **타입 별칭 (Type Alias)**:  
  복잡한 타입을 재사용하기 위해 별칭을 만듦.
  ```typescript
  type User = { id: number; name: string };
  let admin: User = { id: 1, name: "Alice" };
  ```

- **인덱스 시그니처 (Index Signature)**:  
  객체가 동적으로 속성을 가질 때 사용.
  ```typescript
  let data: { [key: string]: number } = { a: 1, b: 2 };
  data["c"] = 3; // 가능
  ```

---

### 6. Enum 타입
- 열거형으로, 이름이 있는 상수 집합을 정의.
  ```typescript
  enum Direction {
    Up,
    Down,
    Left,
    Right,
  }
  let dir: Direction = Direction.Up;
  ```

- 숫자 기반 또는 문자열 기반 Enum 가능.
  ```typescript
  enum Status {
    Success = "SUCCESS",
    Failure = "FAILURE",
  }
  ```

---

### 7. Any와 Unknown 타입
- **Any**:  
  모든 타입을 허용. 타입 검사를 비활성화.
  ```typescript
  let random: any = 42;
  random = "Hello"; // 가능
  ```

- **Unknown**:  
  `any`와 유사하지만, 타입을 명시적으로 확인해야 사용 가능.
  ```typescript
  let value: unknown = "Hello";
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // 가능
  }
  ```

---

### 8. Void와 Never 타입
- **Void**:  
  함수에서 반환값이 없음을 의미.
  ```typescript
  function logMessage(message: string): void {
    console.log(message);
  }
  ```

- **Never**:  
  절대 반환하지 않는 함수의 타입. (예: 에러 발생, 무한 루프)
  ```typescript
  function throwError(errorMsg: string): never {
    throw new Error(errorMsg);
  }
  
